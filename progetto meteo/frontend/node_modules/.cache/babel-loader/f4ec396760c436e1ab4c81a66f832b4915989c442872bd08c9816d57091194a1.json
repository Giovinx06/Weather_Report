{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from \"vue\";\nconst _hoisted_1 = {\n  class: \"chart-3d-container\"\n};\nconst _hoisted_2 = {\n  class: \"chart-3d-controls mb-3 d-flex justify-content-between align-items-center\"\n};\nconst _hoisted_3 = {\n  class: \"btn-group\"\n};\nconst _hoisted_4 = {\n  class: \"chart-3d-canvas-container\"\n};\nconst _hoisted_5 = {\n  ref: \"chart3d\",\n  class: \"chart-3d-canvas\"\n};\nconst _hoisted_6 = {\n  key: 0,\n  class: \"chart-loading\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [_cache[4] || (_cache[4] = _createElementVNode(\"h5\", {\n    class: \"mb-0\"\n  }, \"Grafico 3D Temperatura\", -1 /* HOISTED */)), _createElementVNode(\"div\", _hoisted_3, [_createElementVNode(\"button\", {\n    class: _normalizeClass([\"btn btn-sm\", {\n      'btn-primary': $data.activeView === 'bar',\n      'btn-outline-primary': $data.activeView !== 'bar'\n    }]),\n    onClick: _cache[0] || (_cache[0] = $event => $options.setView('bar'))\n  }, _cache[2] || (_cache[2] = [_createElementVNode(\"i\", {\n    class: \"fas fa-chart-bar me-1\"\n  }, null, -1 /* HOISTED */), _createTextVNode(\" Barre \")]), 2 /* CLASS */), _createElementVNode(\"button\", {\n    class: _normalizeClass([\"btn btn-sm\", {\n      'btn-primary': $data.activeView === 'wave',\n      'btn-outline-primary': $data.activeView !== 'wave'\n    }]),\n    onClick: _cache[1] || (_cache[1] = $event => $options.setView('wave'))\n  }, _cache[3] || (_cache[3] = [_createElementVNode(\"i\", {\n    class: \"fas fa-water me-1\"\n  }, null, -1 /* HOISTED */), _createTextVNode(\" Onde \")]), 2 /* CLASS */)])]), _createElementVNode(\"div\", _hoisted_4, [_createElementVNode(\"canvas\", _hoisted_5, null, 512 /* NEED_PATCH */), $data.loading ? (_openBlock(), _createElementBlock(\"div\", _hoisted_6, _cache[5] || (_cache[5] = [_createElementVNode(\"div\", {\n    class: \"spinner-border text-primary\",\n    role: \"status\"\n  }, [_createElementVNode(\"span\", {\n    class: \"visually-hidden\"\n  }, \"Caricamento...\")], -1 /* HOISTED */)]))) : _createCommentVNode(\"v-if\", true)])]);\n}","map":{"version":3,"names":["class","ref","key","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_hoisted_3","_normalizeClass","$data","activeView","onClick","_cache","$event","$options","setView","_createTextVNode","_hoisted_4","_hoisted_5","loading","_hoisted_6","role","_createCommentVNode"],"sources":["C:\\Users\\Giovanni\\OneDrive\\Desktop\\Scuola\\TPI\\progetto meteo\\frontend\\src\\components\\WeatherChart3D.vue"],"sourcesContent":["<template>\r\n  <div class=\"chart-3d-container\">\r\n    <div class=\"chart-3d-controls mb-3 d-flex justify-content-between align-items-center\">\r\n      <h5 class=\"mb-0\">Grafico 3D Temperatura</h5>\r\n      <div class=\"btn-group\">\r\n        <button \r\n          class=\"btn btn-sm\" \r\n          :class=\"{'btn-primary': activeView === 'bar', 'btn-outline-primary': activeView !== 'bar'}\"\r\n          @click=\"setView('bar')\"\r\n        >\r\n          <i class=\"fas fa-chart-bar me-1\"></i> Barre\r\n        </button>\r\n        <button \r\n          class=\"btn btn-sm\" \r\n          :class=\"{'btn-primary': activeView === 'wave', 'btn-outline-primary': activeView !== 'wave'}\"\r\n          @click=\"setView('wave')\"\r\n        >\r\n          <i class=\"fas fa-water me-1\"></i> Onde\r\n        </button>\r\n      </div>\r\n    </div>\r\n    <div class=\"chart-3d-canvas-container\">\r\n      <canvas ref=\"chart3d\" class=\"chart-3d-canvas\"></canvas>\r\n      <div v-if=\"loading\" class=\"chart-loading\">\r\n        <div class=\"spinner-border text-primary\" role=\"status\">\r\n          <span class=\"visually-hidden\">Caricamento...</span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'WeatherChart3D',\r\n  props: {\r\n    weatherData: {\r\n      type: Array,\r\n      required: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      chart: null,\r\n      ctx: null,\r\n      activeView: 'bar',\r\n      loading: true,\r\n      animationId: null\r\n    }\r\n  },\r\n  mounted() {\r\n    this.setupCanvas();\r\n    window.addEventListener('resize', this.handleResize);\r\n  },\r\n  beforeUnmount() {\r\n    window.removeEventListener('resize', this.handleResize);\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n    }\r\n  },\r\n  methods: {\r\n    setupCanvas() {\r\n      this.ctx = this.$refs.chart3d.getContext('2d');\r\n      this.handleResize();\r\n      this.renderChart();\r\n      setTimeout(() => {\r\n        this.loading = false;\r\n      }, 800);\r\n    },\r\n    handleResize() {\r\n      const container = this.$refs.chart3d.parentElement;\r\n      this.$refs.chart3d.width = container.clientWidth;\r\n      this.$refs.chart3d.height = container.clientHeight;\r\n      this.renderChart();\r\n    },\r\n    setView(view) {\r\n      this.activeView = view;\r\n      this.renderChart();\r\n    },\r\n    renderChart() {\r\n      if (!this.ctx || !this.weatherData.length) return;\r\n      \r\n      // Cancella il canvas\r\n      this.ctx.clearRect(0, 0, this.$refs.chart3d.width, this.$refs.chart3d.height);\r\n      \r\n      // Imposta lo stile di base\r\n      this.ctx.font = '12px Arial';\r\n      this.ctx.textAlign = 'center';\r\n      \r\n      if (this.activeView === 'bar') {\r\n        this.renderBarChart();\r\n      } else {\r\n        this.renderWaveChart();\r\n      }\r\n    },\r\n    renderBarChart() {\r\n      const canvas = this.$refs.chart3d;\r\n      const ctx = this.ctx;\r\n      const data = this.processData();\r\n      \r\n      // Cancella animazione precedente\r\n      if (this.animationId) {\r\n        cancelAnimationFrame(this.animationId);\r\n      }\r\n      \r\n      const margin = { top: 40, right: 40, bottom: 60, left: 60 };\r\n      const width = canvas.width - margin.left - margin.right;\r\n      const height = canvas.height - margin.top - margin.bottom;\r\n      \r\n      // Disegna sfondo e titolo\r\n      ctx.fillStyle = '#f8f9fa';\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n      \r\n      // Disegna assi\r\n      ctx.strokeStyle = '#333';\r\n      ctx.lineWidth = 1;\r\n      ctx.beginPath();\r\n      \r\n      // Asse X\r\n      ctx.moveTo(margin.left, height + margin.top);\r\n      ctx.lineTo(width + margin.left, height + margin.top);\r\n      \r\n      // Asse Y\r\n      ctx.moveTo(margin.left, margin.top);\r\n      ctx.lineTo(margin.left, height + margin.top);\r\n      \r\n      // Asse Z (prospettiva)\r\n      ctx.moveTo(margin.left, height + margin.top);\r\n      ctx.lineTo(margin.left - 30, height + margin.top + 30);\r\n      \r\n      ctx.stroke();\r\n      \r\n      // Calcola le scale per gli assi\r\n      const maxTemp = Math.max(...data.map(d => d.temperature)) + 5;\r\n      const minTemp = Math.min(...data.map(d => d.temperature)) - 5;\r\n      const barWidth = Math.min(30, (width / data.length) * 0.7);\r\n      \r\n      // Angolo per la prospettiva\r\n      const angle = Math.PI / 6;\r\n      \r\n      // Disegna etichette asse Y (temperatura)\r\n      ctx.fillStyle = '#333';\r\n      ctx.textAlign = 'right';\r\n      const tempStep = Math.ceil((maxTemp - minTemp) / 5);\r\n      for (let i = 0; i <= 5; i++) {\r\n        const temp = minTemp + (tempStep * i);\r\n        const y = height + margin.top - ((temp - minTemp) / (maxTemp - minTemp) * height);\r\n        ctx.fillText(`${Math.round(temp)}°C`, margin.left - 5, y);\r\n        \r\n        // Linee di griglia orizzontali\r\n        ctx.strokeStyle = '#ddd';\r\n        ctx.beginPath();\r\n        ctx.moveTo(margin.left, y);\r\n        ctx.lineTo(width + margin.left, y);\r\n        ctx.stroke();\r\n      }\r\n      \r\n      // Variabili per l'animazione\r\n      let progress = 0;\r\n      const animate = () => {\r\n        // Pulisci l'area del grafico (non tutto il canvas)\r\n        ctx.clearRect(margin.left, margin.top, width, height);\r\n        \r\n        // Ridisegna sfondo e griglia\r\n        ctx.fillStyle = '#f8f9fa';\r\n        ctx.fillRect(margin.left, margin.top, width, height);\r\n        \r\n        // Ridisegna linee di griglia\r\n        ctx.strokeStyle = '#ddd';\r\n        for (let i = 0; i <= 5; i++) {\r\n          const temp = minTemp + (tempStep * i);\r\n          const y = height + margin.top - ((temp - minTemp) / (maxTemp - minTemp) * height);\r\n          ctx.beginPath();\r\n          ctx.moveTo(margin.left, y);\r\n          ctx.lineTo(width + margin.left, y);\r\n          ctx.stroke();\r\n        }\r\n        \r\n        // Disegna barre 3D con animazione\r\n        data.forEach((d, i) => {\r\n          const x = margin.left + ((width / (data.length - 1)) * i);\r\n          const normalizedTemp = (d.temperature - minTemp) / (maxTemp - minTemp);\r\n          const barHeight = normalizedTemp * height * Math.min(1, progress);\r\n          \r\n          // Calcola coordinate 3D\r\n          const x1 = x - barWidth / 2;\r\n          const x2 = x + barWidth / 2;\r\n          const y1 = height + margin.top;\r\n          const y2 = y1 - barHeight;\r\n          \r\n          // Profondità dell'effetto 3D\r\n          const depth = barWidth * 0.5;\r\n          \r\n          // Colore basato sulla temperatura\r\n          const hue = 240 - (normalizedTemp * 240); // Da blu (freddo) a rosso (caldo)\r\n          ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;\r\n          \r\n          // Faccia frontale\r\n          ctx.beginPath();\r\n          ctx.rect(x1, y2, barWidth, barHeight);\r\n          ctx.fill();\r\n          \r\n          // Faccia superiore\r\n          ctx.fillStyle = `hsl(${hue}, 80%, 70%)`;\r\n          ctx.beginPath();\r\n          ctx.moveTo(x1, y2);\r\n          ctx.lineTo(x1 + depth * Math.cos(angle), y2 - depth * Math.sin(angle));\r\n          ctx.lineTo(x2 + depth * Math.cos(angle), y2 - depth * Math.sin(angle));\r\n          ctx.lineTo(x2, y2);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n          \r\n          // Faccia laterale\r\n          ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;\r\n          ctx.beginPath();\r\n          ctx.moveTo(x2, y2);\r\n          ctx.lineTo(x2 + depth * Math.cos(angle), y2 - depth * Math.sin(angle));\r\n          ctx.lineTo(x2 + depth * Math.cos(angle), y1 - depth * Math.sin(angle));\r\n          ctx.lineTo(x2, y1);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n          \r\n          // Etichetta città\r\n          if (i % Math.ceil(data.length / 10) === 0) {\r\n            ctx.fillStyle = '#333';\r\n            ctx.textAlign = 'center';\r\n            ctx.save();\r\n            ctx.translate(x, y1 + 15);\r\n            ctx.rotate(Math.PI / 4); // Ruota per evitare sovrapposizioni\r\n            ctx.fillText(d.city, 0, 0);\r\n            ctx.restore();\r\n          }\r\n        });\r\n        \r\n        // Incrementa progresso animazione\r\n        progress += 0.05;\r\n        if (progress < 1) {\r\n          this.animationId = requestAnimationFrame(animate);\r\n        }\r\n      };\r\n      \r\n      // Avvia animazione\r\n      this.animationId = requestAnimationFrame(animate);\r\n    },\r\n    renderWaveChart() {\r\n      const canvas = this.$refs.chart3d;\r\n      const ctx = this.ctx;\r\n      const data = this.processData();\r\n      \r\n      // Cancella animazione precedente\r\n      if (this.animationId) {\r\n        cancelAnimationFrame(this.animationId);\r\n      }\r\n      \r\n      const margin = { top: 40, right: 40, bottom: 60, left: 60 };\r\n      const width = canvas.width - margin.left - margin.right;\r\n      const height = canvas.height - margin.top - margin.bottom;\r\n      \r\n      // Disegna sfondo\r\n      ctx.fillStyle = '#f8f9fa';\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n      \r\n      // Scala per le temperature\r\n      const maxTemp = Math.max(...data.map(d => d.temperature)) + 5;\r\n      const minTemp = Math.min(...data.map(d => d.temperature)) - 5;\r\n      \r\n      // Variabili per l'animazione dell'onda\r\n      let time = 0;\r\n      const frequency = 0.1;\r\n      const amplitude = 10;\r\n      \r\n      // Funzione di animazione\r\n      const animate = () => {\r\n        // Pulisci l'area del grafico\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        \r\n        // Ridisegna sfondo\r\n        ctx.fillStyle = '#f8f9fa';\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        \r\n        // Disegna assi e griglie come nel grafico a barre\r\n        ctx.strokeStyle = '#333';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(margin.left, height + margin.top);\r\n        ctx.lineTo(width + margin.left, height + margin.top);\r\n        ctx.moveTo(margin.left, margin.top);\r\n        ctx.lineTo(margin.left, height + margin.top);\r\n        ctx.stroke();\r\n        \r\n        // Disegna etichette asse Y (temperatura)\r\n        ctx.fillStyle = '#333';\r\n        ctx.textAlign = 'right';\r\n        const tempStep = Math.ceil((maxTemp - minTemp) / 5);\r\n        for (let i = 0; i <= 5; i++) {\r\n          const temp = minTemp + (tempStep * i);\r\n          const y = height + margin.top - ((temp - minTemp) / (maxTemp - minTemp) * height);\r\n          ctx.fillText(`${Math.round(temp)}°C`, margin.left - 5, y);\r\n          \r\n          // Linee di griglia orizzontali\r\n          ctx.strokeStyle = '#ddd';\r\n          ctx.beginPath();\r\n          ctx.moveTo(margin.left, y);\r\n          ctx.lineTo(width + margin.left, y);\r\n          ctx.stroke();\r\n        }\r\n        \r\n        // Crea superficie 3D\r\n        const gridSize = Math.min(50, data.length);\r\n        const cellWidth = width / gridSize;\r\n        const cellHeight = height / gridSize;\r\n        \r\n        for (let i = 0; i < gridSize; i++) {\r\n          for (let j = 0; j < gridSize; j++) {\r\n            // Coordinate nel piano\r\n            const x = margin.left + (cellWidth * i);\r\n            const y = margin.top + (cellHeight * j);\r\n            \r\n            // Calcola il valore dell'onda per questa cella\r\n            const distanceFromCenter = Math.sqrt(\r\n              Math.pow((i - gridSize / 2) / (gridSize / 2), 2) + \r\n              Math.pow((j - gridSize / 2) / (gridSize / 2), 2)\r\n            );\r\n            \r\n            // Combinazione di onde\r\n            const wave1 = Math.sin(distanceFromCenter * 5 + time) * amplitude;\r\n            const wave2 = Math.cos(distanceFromCenter * 3 - time * 0.5) * amplitude;\r\n            const wave = wave1 + wave2;\r\n            \r\n            // Normalizza per avere un valore di colore\r\n            const normalizedWave = (wave + 2 * amplitude) / (4 * amplitude);\r\n            \r\n            // Colore basato sulla \"temperatura\" dell'onda\r\n            const hue = 240 - (normalizedWave * 240);\r\n            ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;\r\n            \r\n            // Disegna la cella\r\n            ctx.beginPath();\r\n            ctx.rect(x, y, cellWidth + 1, cellHeight + 1); // +1 per evitare spazi vuoti\r\n            ctx.fill();\r\n          }\r\n        }\r\n        \r\n        // Disegna linea del profilo dei dati\r\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\r\n        ctx.lineWidth = 3;\r\n        ctx.beginPath();\r\n        ctx.moveTo(margin.left, height + margin.top - ((data[0].temperature - minTemp) / (maxTemp - minTemp) * height));\r\n        \r\n        for (let i = 1; i < data.length; i++) {\r\n          const x = margin.left + ((width / (data.length - 1)) * i);\r\n          const normalizedTemp = (data[i].temperature - minTemp) / (maxTemp - minTemp);\r\n          const y = height + margin.top - (normalizedTemp * height);\r\n          \r\n          ctx.lineTo(x, y);\r\n        }\r\n        ctx.stroke();\r\n        \r\n        // Disegna punti dati\r\n        data.forEach((d, i) => {\r\n          const x = margin.left + ((width / (data.length - 1)) * i);\r\n          const normalizedTemp = (d.temperature - minTemp) / (maxTemp - minTemp);\r\n          const y = height + margin.top - (normalizedTemp * height);\r\n          \r\n          const hue = 240 - (normalizedTemp * 240);\r\n          \r\n          // Punto\r\n          ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;\r\n          ctx.beginPath();\r\n          ctx.arc(x, y, 5, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          \r\n          // Etichetta città (solo alcune per evitare sovrapposizioni)\r\n          if (i % Math.ceil(data.length / 6) === 0) {\r\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n            ctx.textAlign = 'center';\r\n            ctx.fillText(d.city, x, y - 15);\r\n          }\r\n        });\r\n        \r\n        // Incrementa il tempo per l'animazione\r\n        time += 0.05;\r\n        this.animationId = requestAnimationFrame(animate);\r\n      };\r\n      \r\n      // Avvia animazione\r\n      this.animationId = requestAnimationFrame(animate);\r\n    },\r\n    processData() {\r\n      // Elabora e prepara i dati per la visualizzazione\r\n      return this.weatherData\r\n        .filter(item => item.temperature !== undefined)\r\n        .map(item => ({\r\n          city: item.city,\r\n          temperature: parseFloat(item.temperature),\r\n          description: item.description\r\n        }));\r\n    }\r\n  },\r\n  watch: {\r\n    weatherData: {\r\n      handler() {\r\n        this.renderChart();\r\n      },\r\n      deep: true\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.chart-3d-container {\r\n  width: 100%;\r\n  position: relative;\r\n  background-color: white;\r\n  border-radius: 0.75rem;\r\n  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);\r\n  padding: 1rem;\r\n  margin-bottom: 1.5rem;\r\n}\r\n\r\n.chart-3d-canvas-container {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 400px;\r\n}\r\n\r\n.chart-3d-canvas {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.chart-loading {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  background-color: rgba(255, 255, 255, 0.7);\r\n  z-index: 10;\r\n}\r\n</style> "],"mappings":";;EACOA,KAAK,EAAC;AAAoB;;EACxBA,KAAK,EAAC;AAA0E;;EAE9EA,KAAK,EAAC;AAAW;;EAiBnBA,KAAK,EAAC;AAA2B;;EAC5BC,GAAG,EAAC,SAAS;EAACD,KAAK,EAAC;;;EAtBlCE,GAAA;EAuB0BF,KAAK,EAAC;;;uBAtB9BG,mBAAA,CA4BM,OA5BNC,UA4BM,GA3BJC,mBAAA,CAkBM,OAlBNC,UAkBM,G,0BAjBJD,mBAAA,CAA4C;IAAxCL,KAAK,EAAC;EAAM,GAAC,wBAAsB,sBACvCK,mBAAA,CAeM,OAfNE,UAeM,GAdJF,mBAAA,CAMS;IALPL,KAAK,EANfQ,eAAA,EAMgB,YAAY;MAAA,eACMC,KAAA,CAAAC,UAAU;MAAA,uBAAmCD,KAAA,CAAAC,UAAU;IAAA;IAC9EC,OAAK,EAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEC,QAAA,CAAAC,OAAO;gCAEfV,mBAAA,CAAqC;IAAlCL,KAAK,EAAC;EAAuB,4BAV1CgB,gBAAA,CAU+C,SACvC,E,mBACAX,mBAAA,CAMS;IALPL,KAAK,EAbfQ,eAAA,EAagB,YAAY;MAAA,eACMC,KAAA,CAAAC,UAAU;MAAA,uBAAoCD,KAAA,CAAAC,UAAU;IAAA;IAC/EC,OAAK,EAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEC,QAAA,CAAAC,OAAO;gCAEfV,mBAAA,CAAiC;IAA9BL,KAAK,EAAC;EAAmB,4BAjBtCgB,gBAAA,CAiB2C,QACnC,E,uBAGJX,mBAAA,CAOM,OAPNY,UAOM,GANJZ,mBAAA,CAAuD,UAAvDa,UAAuD,+BAC5CT,KAAA,CAAAU,OAAO,I,cAAlBhB,mBAAA,CAIM,OAJNiB,UAIM,EAAAR,MAAA,QAAAA,MAAA,OAHJP,mBAAA,CAEM;IAFDL,KAAK,EAAC,6BAA6B;IAACqB,IAAI,EAAC;MAC5ChB,mBAAA,CAAmD;IAA7CL,KAAK,EAAC;EAAiB,GAAC,gBAAc,E,0BAzBtDsB,mBAAA,e","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}